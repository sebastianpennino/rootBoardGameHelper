/*

interface BaseConfig {
  name: Methods.PICK | Methods.RANDOM | Methods.PRIORITY | ''
}


interface RandomMethodConfig extends BaseConfig {
  options: {
    doubleVagaBond: boolean
    availableFactions: ValidFactions[]
    method:
      | ValidRandomMethods.TRULY_RANDOM
      | ValidRandomMethods.OTHER2
      | ValidRandomMethods.OTHER3
      | ''
  }
}

interface PlayerFaction {
  name: string
  faction: ValidFactions
  reach: number
}

interface IStore {
  players: string[]
  config: RandomMethodConfig
  results: {
    method: Methods.PICK | Methods.RANDOM | Methods.PRIORITY | ''
    playerFactions: PlayerFaction[]
  }
}
*/

/*

export let store: IStore = {
  players: ['pepe', 'juan', 'pedro'],
  config: {
    name: Methods.RANDOM,
    options: {
      doubleVagaBond: false,
      availableFactions: [Factions.MARQUISE_THE_CAT, Factions.EERYE_DINASTY, Factions.VAGABOND1],
      method: ValidRandomMethods.TRULY_RANDOM,
    },
  },
  results: {
    method: Methods.RANDOM,
    playerFactions: [
      {
        name: 'pepe',
        faction: Factions.CORVID_CONSPIRACY,
        reach: 9,
      },
    ],
  },
}

const initialState: IStore = {
  players: [],
  config: {
    name: '',
    options: {
      doubleVagaBond: false,
      availableFactions: [],
      method: '',
    },
  },
  results: {
    method: '',
    playerFactions: [],
  },
}

export enum Actions {
  ADD_PLAYER = 'ADD_PLAYER',
  REMOVE_PLAYER = 'REMOVE_PLAYER',
  UPDATE_CONFIG = 'UPDATE_CONFIG',
  UPDATE_RESULTS = 'UPDATE_RESULTS',
}

type ValidActionTypes =
  | Actions.ADD_PLAYER
  | Actions.REMOVE_PLAYER
  | Actions.UPDATE_CONFIG
  | Actions.UPDATE_RESULTS
interface Action {
  type: ValidActionTypes
  payload?: any
}

const handlers = {
  [Actions.ADD_PLAYER]: (state: any, action: Action) => {
    // this is not ok, but it will work for now
    return {
      ...state,
      players: state.players.concat(action.payload),
    }
  },
  [Actions.REMOVE_PLAYER]: (state: any, action: Action) => {
    return {
      ...state,
      players: state.players.filter((player: string) => player !== action.payload),
    }
  },
  [Actions.UPDATE_CONFIG]: (state: any, action: Action) => {
    return {
      ...state,
      config: action.payload
    }
  },
  [Actions.UPDATE_RESULTS]: (state: any, action: Action) => {
    return {
      ...state,
      result: action.payload
    }
  },
}

// Why is that function called a reducer? Because it would plug right into a standard reduce function.
//
// const actions = [
//   {type: CREATE_NOTE},
//   {type: UPDATE_NOTE, payload: 'something' }
// ];
// 
// const state = actions.reduce(reducer, undefined);
//
// will get state in the same pos as doting those two in sequence
const mainReducer = (state = initialState, action: Action) => {
  if (handlers[action.type]) {
    return handlers[action.type](state, action)
  }
  return state
}

*/


